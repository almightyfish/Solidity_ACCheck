#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
‰∏Ä‰ΩìÂåñÊô∫ËÉΩÂêàÁ∫¶Ê±°ÁÇπÂàÜÊûêÂ∑•ÂÖ∑
ÈõÜÊàêÔºöÁºñËØë ‚Üí Â≠óËäÇÁ†ÅÂàÜÊûê ‚Üí Ê±°ÁÇπÂàÜÊûê ‚Üí Ê∫êÁ†ÅÊò†Â∞Ñ ‚Üí Êä•ÂëäÁîüÊàê

‰ΩøÁî®ÊñπÊ≥ïÔºö
    Âè™ÈúÄÈÖçÁΩÆ‰ª•‰∏ã3‰∏™ÂèÇÊï∞Âç≥ÂèØËøêË°åÔºö
    - SOLC_VERSION: solcÁâàÊú¨ÔºàÂ¶Ç "0.4.25", "0.8.0"Ôºâ
    - KEY_VARIABLES: ÂÖ≥ÈîÆÂèòÈáèÂàóË°®
    - CONTRACT_PATH: SolidityÊ∫êÁ†ÅË∑ØÂæÑ
"""

import json
import os
import sys
import re
import subprocess
import tempfile
from pathlib import Path
from datetime import datetime
from typing import List, Dict, Any, Optional


# ============================================================================
# ÈÖçÁΩÆÂå∫Âüü - Âè™ÈúÄ‰øÆÊîπËøôÈáåÔºÅ
# ============================================================================

SOLC_VERSION = "0.4.25"  # SolidityÁºñËØëÂô®ÁâàÊú¨
KEY_VARIABLES = ["totalSupply", "balances", "rate"]  # Ë¶ÅÂàÜÊûêÁöÑÂÖ≥ÈîÆÂèòÈáè
CONTRACT_PATH = "/Users/almightyfish/Desktop/AChecker/AC/undependency/0xf41624c6465e57a0dca498ef0b62f07cbaab09ca.sol"  # SolidityÊ∫êÁ†ÅÊñá‰ª∂Ë∑ØÂæÑ

# ÂèØÈÄâÈÖçÁΩÆ
OUTPUT_DIR = "analysis_output_4"  # ËæìÂá∫ÁõÆÂΩï
KEEP_TEMP_FILES = True  # ÊòØÂê¶‰øùÁïô‰∏≠Èó¥Êñá‰ª∂

# ============================================================================


class Colors:
    """ÁªàÁ´ØÈ¢úËâ≤"""
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'


# ============================================================================
# Á¨¨1ÈÉ®ÂàÜÔºöSolcÁâàÊú¨ÁÆ°ÁêÜÂíåÁºñËØë
# ============================================================================

class SolcManager:
    """SolcÁâàÊú¨ÁÆ°ÁêÜÂô®"""
    
    def __init__(self, version: str):
        self.version = version
        self.solc_path = None
    
    def check_and_switch_version(self) -> bool:
        """Ê£ÄÊü•Âπ∂ÂàáÊç¢Âà∞ÊåáÂÆöÁöÑsolcÁâàÊú¨"""
        print(f"\n{Colors.HEADER}„ÄêÊ≠•È™§1„ÄëÊ£ÄÊü•ÂíåÂàáÊç¢SolcÁâàÊú¨{Colors.ENDC}")
        print("-" * 80)
        
        # Ê£ÄÊü•ÊòØÂê¶ÂÆâË£Ö‰∫Üsolc-select
        try:
            result = subprocess.run(['solc-select', 'versions'], 
                                  capture_output=True, text=True, timeout=10)
            has_solc_select = result.returncode == 0
        except (FileNotFoundError, subprocess.TimeoutExpired):
            has_solc_select = False
        
        if has_solc_select:
            print(f"‚úì Ê£ÄÊµãÂà∞ solc-select")
            return self._use_solc_select()
        else:
            print(f"‚ö†Ô∏è  Êú™Ê£ÄÊµãÂà∞ solc-selectÔºåÂ∞ùËØï‰ΩøÁî®Á≥ªÁªüsolc")
            return self._use_system_solc()
    
    def _use_solc_select(self) -> bool:
        """‰ΩøÁî®solc-selectÂàáÊç¢ÁâàÊú¨"""
        try:
            # Ê£ÄÊü•ÊòØÂê¶Â∑≤ÂÆâË£ÖÊâÄÈúÄÁâàÊú¨
            result = subprocess.run(['solc-select', 'versions'], 
                                  capture_output=True, text=True)
            installed_versions = result.stdout
            
            if self.version not in installed_versions:
                print(f"üì¶ ÂÆâË£Ö solc {self.version}...")
                subprocess.run(['solc-select', 'install', self.version], 
                             check=True, capture_output=True)
                print(f"‚úì ÂÆâË£ÖÂÆåÊàê")
            
            # ÂàáÊç¢ÁâàÊú¨
            print(f"üîÑ ÂàáÊç¢Âà∞ solc {self.version}...")
            subprocess.run(['solc-select', 'use', self.version], 
                         check=True, capture_output=True)
            
            self.solc_path = 'solc'
            
            # È™åËØÅÁâàÊú¨
            result = subprocess.run(['solc', '--version'], 
                                  capture_output=True, text=True)
            print(f"‚úì ÂΩìÂâçÁâàÊú¨: {result.stdout.split('Version:')[1].split()[0]}")
            return True
            
        except Exception as e:
            print(f"‚ùå solc-selectÂàáÊç¢Â§±Ë¥•: {e}")
            return False
    
    def _use_system_solc(self) -> bool:
        """‰ΩøÁî®Á≥ªÁªüÈªòËÆ§solc"""
        try:
            result = subprocess.run(['solc', '--version'], 
                                  capture_output=True, text=True)
            if result.returncode == 0:
                version_info = result.stdout
                print(f"‚úì ÊâæÂà∞Á≥ªÁªüsolc")
                print(f"  ÁâàÊú¨‰ø°ÊÅØ: {version_info.split('Version:')[1].split()[0] if 'Version:' in version_info else 'Unknown'}")
                self.solc_path = 'solc'
                return True
            return False
        except FileNotFoundError:
            print(f"‚ùå Êú™ÊâæÂà∞solcÁºñËØëÂô®")
            print(f"\nÂÆâË£ÖÂª∫ËÆÆ:")
            print(f"  1. ‰ΩøÁî® solc-select (Êé®Ëçê):")
            print(f"     pip install solc-select")
            print(f"     solc-select install {self.version}")
            print(f"     solc-select use {self.version}")
            print(f"  2. ÊàñÂÆâË£ÖÁ≥ªÁªüsolc:")
            print(f"     macOS: brew install solidity")
            print(f"     Linux: apt-get install solc")
            return False


class ContractCompiler:
    """ÂêàÁ∫¶ÁºñËØëÂô®"""
    
    def __init__(self, solc_path: str, output_dir: str):
        self.solc_path = solc_path
        self.output_dir = output_dir
        self.bytecode = None
        self.runtime_bytecode = None
        self.asm = None
        self.srcmap = None
        self.srcmap_runtime = None
    
    def compile(self, contract_path: str) -> bool:
        """ÁºñËØëÂêàÁ∫¶"""
        print(f"\n{Colors.HEADER}„ÄêÊ≠•È™§2„ÄëÁºñËØëÂêàÁ∫¶{Colors.ENDC}")
        print("-" * 80)
        print(f"Ê∫êÊñá‰ª∂: {contract_path}")
        
        try:
            # ÁºñËØëÂëΩ‰ª§ÔºàÂÖºÂÆπ‰∏çÂêåÁâàÊú¨Ôºâ
            cmd = [
                self.solc_path,
                '--bin', '--bin-runtime', '--asm',
                '--overwrite',
                '-o', self.output_dir,
                contract_path
            ]
            
            print(f"ÊâßË°åÂëΩ‰ª§: {' '.join(cmd)}")
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
            
            if result.returncode != 0:
                print(f"{Colors.RED}‚ùå ÁºñËØëÂ§±Ë¥•:{Colors.ENDC}")
                print(result.stderr)
                return False
            
            # ËØªÂèñÁºñËØë‰∫ßÁâ©
            contract_name = self._extract_contract_name(contract_path)
            self._load_artifacts(contract_name)
            
            print(f"{Colors.GREEN}‚úì ÁºñËØëÊàêÂäü{Colors.ENDC}")
            print(f"  - Runtime bytecode: {len(self.runtime_bytecode)} Â≠óÁ¨¶")
            print(f"  - Bytecode: {len(self.bytecode)} Â≠óÁ¨¶")
            
            # ‰øùÂ≠ò‰∏≠Èó¥ÁªìÊûú
            self._save_intermediate_files()
            
            return True
            
        except subprocess.TimeoutExpired:
            print(f"{Colors.RED}‚ùå ÁºñËØëË∂ÖÊó∂{Colors.ENDC}")
            return False
        except Exception as e:
            print(f"{Colors.RED}‚ùå ÁºñËØëÈîôËØØ: {e}{Colors.ENDC}")
            import traceback
            traceback.print_exc()
            return False
    
    def _extract_contract_name(self, contract_path: str) -> str:
        """ÊèêÂèñÂêàÁ∫¶ÂêçÁß∞"""
        with open(contract_path, 'r') as f:
            content = f.read()
        match = re.search(r'contract\s+(\w+)', content)
        return match.group(1) if match else Path(contract_path).stem
    
    def _load_artifacts(self, contract_name: str):
        """Âä†ËΩΩÁºñËØë‰∫ßÁâ©"""
        base_path = os.path.join(self.output_dir, contract_name)
        
        # ËØªÂèñÂêÑÁßçÁºñËØë‰∫ßÁâ©ÔºàÂÖºÂÆπ‰∏çÂêåsolcÁâàÊú¨Ôºâ
        files = {
            'bin': 'bytecode',
            'bin-runtime': 'runtime_bytecode',
            'asm': 'asm'
        }
        
        for ext, attr in files.items():
            file_path = f"{base_path}.{ext}"
            if os.path.exists(file_path):
                with open(file_path, 'r') as f:
                    setattr(self, attr, f.read().strip())
    
    def _save_intermediate_files(self):
        """‰øùÂ≠ò‰∏≠Èó¥Êñá‰ª∂"""
        intermediate_dir = os.path.join(self.output_dir, "intermediate")
        os.makedirs(intermediate_dir, exist_ok=True)
        
        # ‰øùÂ≠òruntime bytecode
        with open(os.path.join(intermediate_dir, "runtime_bytecode.hex"), 'w') as f:
            f.write(self.runtime_bytecode)
        
        print(f"  ‚Üí ‰∏≠Èó¥Êñá‰ª∂Â∑≤‰øùÂ≠òÂà∞: {intermediate_dir}/")


# ============================================================================
# Á¨¨2ÈÉ®ÂàÜÔºöÂ≠óËäÇÁ†ÅÂàÜÊûê
# ============================================================================

EVM_OPCODES = {
    0x00: 'STOP', 0x01: 'ADD', 0x02: 'MUL', 0x03: 'SUB', 0x04: 'DIV',
    0x05: 'SDIV', 0x06: 'MOD', 0x07: 'SMOD', 0x08: 'ADDMOD', 0x09: 'MULMOD',
    0x0a: 'EXP', 0x0b: 'SIGNEXTEND',
    0x10: 'LT', 0x11: 'GT', 0x12: 'SLT', 0x13: 'SGT', 0x14: 'EQ', 0x15: 'ISZERO',
    0x16: 'AND', 0x17: 'OR', 0x18: 'XOR', 0x19: 'NOT', 0x1a: 'BYTE',
    0x20: 'SHA3',
    0x30: 'ADDRESS', 0x31: 'BALANCE', 0x32: 'ORIGIN', 0x33: 'CALLER', 0x34: 'CALLVALUE',
    0x35: 'CALLDATALOAD', 0x36: 'CALLDATASIZE', 0x37: 'CALLDATACOPY', 0x38: 'CODESIZE',
    0x39: 'CODECOPY', 0x3a: 'GASPRICE', 0x3b: 'EXTCODESIZE', 0x3c: 'EXTCODECOPY',
    0x3d: 'RETURNDATASIZE', 0x3e: 'RETURNDATACOPY', 0x3f: 'EXTCODEHASH',
    0x40: 'BLOCKHASH', 0x41: 'COINBASE', 0x42: 'TIMESTAMP', 0x43: 'NUMBER', 
    0x44: 'DIFFICULTY', 0x45: 'GASLIMIT', 0x46: 'CHAINID', 0x47: 'SELFBALANCE',
    0x50: 'POP', 0x51: 'MLOAD', 0x52: 'MSTORE', 0x53: 'MSTORE8', 0x54: 'SLOAD', 0x55: 'SSTORE',
    0x56: 'JUMP', 0x57: 'JUMPI', 0x58: 'PC', 0x59: 'MSIZE', 0x5a: 'GAS', 0x5b: 'JUMPDEST',
    0x60: 'PUSH1', 0x61: 'PUSH2', 0x62: 'PUSH3', 0x63: 'PUSH4', 0x64: 'PUSH5', 
    0x65: 'PUSH6', 0x66: 'PUSH7', 0x67: 'PUSH8', 0x68: 'PUSH9', 0x69: 'PUSH10', 
    0x6a: 'PUSH11', 0x6b: 'PUSH12', 0x6c: 'PUSH13', 0x6d: 'PUSH14', 0x6e: 'PUSH15', 
    0x6f: 'PUSH16', 0x70: 'PUSH17', 0x71: 'PUSH18', 0x72: 'PUSH19', 0x73: 'PUSH20', 
    0x74: 'PUSH21', 0x75: 'PUSH22', 0x76: 'PUSH23', 0x77: 'PUSH24', 0x78: 'PUSH25', 
    0x79: 'PUSH26', 0x7a: 'PUSH27', 0x7b: 'PUSH28', 0x7c: 'PUSH29', 0x7d: 'PUSH30', 
    0x7e: 'PUSH31', 0x7f: 'PUSH32',
    0x80: 'DUP1', 0x81: 'DUP2', 0x82: 'DUP3', 0x83: 'DUP4', 0x84: 'DUP5', 
    0x85: 'DUP6', 0x86: 'DUP7', 0x87: 'DUP8', 0x88: 'DUP9', 0x89: 'DUP10', 
    0x8a: 'DUP11', 0x8b: 'DUP12', 0x8c: 'DUP13', 0x8d: 'DUP14', 0x8e: 'DUP15', 0x8f: 'DUP16',
    0x90: 'SWAP1', 0x91: 'SWAP2', 0x92: 'SWAP3', 0x93: 'SWAP4', 0x94: 'SWAP5', 
    0x95: 'SWAP6', 0x96: 'SWAP7', 0x97: 'SWAP8', 0x98: 'SWAP9', 0x99: 'SWAP10', 
    0x9a: 'SWAP11', 0x9b: 'SWAP12', 0x9c: 'SWAP13', 0x9d: 'SWAP14', 0x9e: 'SWAP15', 0x9f: 'SWAP16',
    0xa0: 'LOG0', 0xa1: 'LOG1', 0xa2: 'LOG2', 0xa3: 'LOG3', 0xa4: 'LOG4',
    0xf0: 'CREATE', 0xf1: 'CALL', 0xf2: 'CALLCODE', 0xf3: 'RETURN', 0xf4: 'DELEGATECALL', 
    0xf5: 'CREATE2', 0xfa: 'STATICCALL', 0xfd: 'REVERT', 0xfe: 'INVALID', 0xff: 'SELFDESTRUCT',
}


class BytecodeAnalyzer:
    """Â≠óËäÇÁ†ÅÂàÜÊûêÂô®"""
    
    def __init__(self, bytecode: str, key_variables: List[str], output_dir: str):
        self.bytecode = bytecode
        self.key_variables = key_variables
        self.output_dir = output_dir
        self.instructions = []
        self.basic_blocks = []
        self.cfg = {}
        self.var_storage_map = {}
    
    def analyze(self) -> bool:
        """ÊâßË°åÂÆåÊï¥ÂàÜÊûê"""
        print(f"\n{Colors.HEADER}„ÄêÊ≠•È™§3„ÄëÂ≠óËäÇÁ†ÅÂàÜÊûê{Colors.ENDC}")
        print("-" * 80)
        
        # ÂèçÊ±áÁºñ
        self.instructions = self.disassemble()
        print(f"‚úì ÂèçÊ±áÁºñÂÆåÊàê: {len(self.instructions)} Êù°Êåá‰ª§")
        
        # ÊûÑÂª∫CFG
        self.analyze_cfg()
        print(f"‚úì CFGÂàÜÊûêÂÆåÊàê: {len(self.basic_blocks)} ‰∏™Âü∫Êú¨Âùó")
        
        # Êò†Â∞ÑÂèòÈáèÂà∞Â≠òÂÇ®
        self.match_key_vars_to_storage()
        print(f"‚úì ÂèòÈáèÂ≠òÂÇ®Êò†Â∞Ñ:")
        for var, info in self.var_storage_map.items():
            print(f"    {var} ‚Üí slot {info.get('slot')}")
        
        # ‰øùÂ≠ò‰∏≠Èó¥ÁªìÊûú
        self._save_analysis_results()
        
        return True
    
    def disassemble(self) -> List[Dict]:
        """ÂèçÊ±áÁºñÂ≠óËäÇÁ†Å"""
        code = self.bytecode
        if code.startswith('0x'):
            code = code[2:]
        code_bytes = bytes.fromhex(code)
        
        instructions = []
        i = 0
        while i < len(code_bytes):
            opcode = code_bytes[i]
            op = EVM_OPCODES.get(opcode, f'UNKNOWN_{opcode:02x}')
            instr = {'offset': i, 'opcode': opcode, 'op': op}
            
            if 0x60 <= opcode <= 0x7f:  # PUSH1-PUSH32
                push_len = opcode - 0x5f
                instr['push_data'] = code_bytes[i+1:i+1+push_len].hex()
                i += push_len
            
            instructions.append(instr)
            i += 1
        
        return instructions
    
    def analyze_cfg(self):
        """ÂàÜÊûêÊéßÂà∂ÊµÅÂõæ"""
        # ËØÜÂà´Âü∫Êú¨ÂùóËµ∑ÂßãÁÇπ
        jumpdests = set(instr['offset'] for instr in self.instructions if instr['op'] == 'JUMPDEST')
        block_starts = set([0]) | jumpdests
        
        for idx, instr in enumerate(self.instructions):
            if instr['op'] in ('JUMP', 'JUMPI') and idx+1 < len(self.instructions):
                block_starts.add(self.instructions[idx+1]['offset'])
        
        block_starts = sorted(block_starts)
        
        # ÂàÜÂâ≤Âü∫Êú¨Âùó
        blocks = []
        for i, start in enumerate(block_starts):
            end = block_starts[i+1] if i+1 < len(block_starts) else len(self.bytecode)//2
            block_instrs = [instr for instr in self.instructions if start <= instr['offset'] < end]
            blocks.append({'start': start, 'end': end, 'instructions': block_instrs})
        
        self.basic_blocks = blocks
        
        # ÊûÑÂª∫CFG
        cfg = {b['start']: set() for b in blocks}
        for b in blocks:
            if not b['instructions']:
                continue
            last = b['instructions'][-1]
            
            if last['op'] not in ('RETURN', 'STOP', 'SELFDESTRUCT', 'REVERT', 'INVALID', 'JUMP'):
                # È°∫Â∫èÊµÅ
                next_block = None
                for s in block_starts:
                    if s > b['start']:
                        next_block = s
                        break
                if next_block:
                    cfg[b['start']].add(next_block)
            
            if last['op'] == 'JUMPI':
                # Êù°‰ª∂Ë∑≥ËΩ¨ÁöÑfallthrough
                next_block = None
                for s in block_starts:
                    if s > b['start']:
                        next_block = s
                        break
                if next_block:
                    cfg[b['start']].add(next_block)
        
        self.cfg = {k: list(v) for k, v in cfg.items()}
    
    def match_key_vars_to_storage(self):
        """Êò†Â∞ÑÂèòÈáèÂà∞Â≠òÂÇ®ÊßΩ‰Ωç"""
        for idx, var in enumerate(self.key_variables):
            self.var_storage_map[var] = {"slot": idx}
    
    def _save_analysis_results(self):
        """‰øùÂ≠òÂàÜÊûêÁªìÊûú"""
        output_file = os.path.join(self.output_dir, "intermediate", "bytecode_analysis.json")
        os.makedirs(os.path.dirname(output_file), exist_ok=True)
        
        result = {
            'instructions_count': len(self.instructions),
            'basic_blocks_count': len(self.basic_blocks),
            'cfg': self.cfg,
            'variable_storage_map': self.var_storage_map,
            'instructions_sample': self.instructions[:20]
        }
        
        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump(result, f, indent=2, ensure_ascii=False)
        
        print(f"  ‚Üí Â≠óËäÇÁ†ÅÂàÜÊûêÁªìÊûú: {output_file}")


# ============================================================================
# Á¨¨3ÈÉ®ÂàÜÔºöÊ±°ÁÇπÂàÜÊûê
# ============================================================================

class TaintAnalyzer:
    """Ê±°ÁÇπÂàÜÊûêÂô®"""
    
    def __init__(self, bytecode_analyzer: BytecodeAnalyzer, output_dir: str):
        self.bytecode_analyzer = bytecode_analyzer
        self.output_dir = output_dir
        self.taint_results = []
    
    def analyze(self) -> bool:
        """ÊâßË°åÊ±°ÁÇπÂàÜÊûê"""
        print(f"\n{Colors.HEADER}„ÄêÊ≠•È™§4„ÄëÊ±°ÁÇπÂàÜÊûê{Colors.ENDC}")
        print("-" * 80)
        
        bb = self.bytecode_analyzer.basic_blocks
        cfg = self.bytecode_analyzer.cfg
        var_storage_map = self.bytecode_analyzer.var_storage_map
        
        # 1. ÊâæÂà∞Ê±°ÁÇπÊ∫ê
        taint_sources = set()
        for b in bb:
            for instr in b['instructions']:
                if instr['op'] in ('CALLDATALOAD', 'CALLDATACOPY', 'CALLER', 'ORIGIN'):
                    taint_sources.add(b['start'])
        
        print(f"‚úì ËØÜÂà´Âà∞ {len(taint_sources)} ‰∏™Ê±°ÁÇπÊ∫êÂü∫Êú¨Âùó")
        
        # 2. ‰∏∫ÊØè‰∏™ÂèòÈáèËøΩË∏™Ê±°ÁÇπ
        results = []
        for var, info in var_storage_map.items():
            slot = info.get('slot')
            
            # ÊâæÂà∞Êìç‰ΩúËØ•slotÁöÑSSTORE/SLOAD
            sink_bbs = set()
            for b in bb:
                for idx, instr in enumerate(b['instructions']):
                    if instr['op'] in ('SSTORE', 'SLOAD'):
                        if self._find_slot_in_stack(b['instructions'], idx, slot):
                            sink_bbs.add(b['start'])
            
            # Ê±°ÁÇπ‰º†Êí≠ÔºàBFSÔºâ
            all_paths = []
            queue = [(src, [src]) for src in taint_sources]
            visited = set()
            
            while queue:
                curr, path = queue.pop(0)
                if curr in sink_bbs:
                    all_paths.append(path)
                    continue
                
                for succ in cfg.get(curr, []):
                    if (curr, succ) not in visited:
                        queue.append((succ, path + [succ]))
                        visited.add((curr, succ))
            
            # Ê±áÊÄª
            taint_bb_set = set()
            for p in all_paths:
                taint_bb_set.update(p)
            
            # 3. Ê£ÄÊµãË∑ØÂæÑ‰∏äÁöÑÊù°‰ª∂Âà§Êñ≠ÔºàÊñ∞Â¢ûÔºâ
            paths_with_conditions = []
            for path in all_paths:
                has_condition = self._check_path_has_condition(path, bb)
                paths_with_conditions.append({
                    'path': path,
                    'has_condition': has_condition
                })
            
            result = {
                "name": var,
                "offset": slot,
                "taint_bb": sorted(list(taint_bb_set)),
                "taint_cfg": all_paths,
                "paths_with_conditions": paths_with_conditions  # Êñ∞Â¢û
            }
            results.append(result)
        
        self.taint_results = results
        
        # ÁªüËÆ°
        vulnerable_count = sum(1 for r in results if r['taint_bb'])
        print(f"{Colors.GREEN}‚úì Ê±°ÁÇπÂàÜÊûêÂÆåÊàê{Colors.ENDC}")
        print(f"  - ÂàÜÊûêÂèòÈáè: {len(results)} ‰∏™")
        print(f"  - Ê£ÄÊµãÂà∞Ê±°ÁÇπ: {vulnerable_count} ‰∏™")
        
        # ‰øùÂ≠òÁªìÊûú
        self._save_taint_results()
        
        return True
    
    def _find_slot_in_stack(self, instructions, idx, target_slot):
        """Êü•ÊâæÊ†à‰∏≠ÁöÑslot"""
        for back in range(1, 6):
            i = idx - back
            if i < 0:
                break
            instr = instructions[i]
            if instr['op'].startswith('PUSH'):
                try:
                    pushed = int(instr.get('push_data', '0'), 16)
                    if pushed == target_slot:
                        return True
                except:
                    continue
            elif instr['op'].startswith(('DUP', 'SWAP')):
                continue
            else:
                break
        return False
    
    def _check_path_has_condition(self, path: List[int], basic_blocks: List[Dict]) -> bool:
        """
        Ê£ÄÊü•Ê±°ÁÇπË∑ØÂæÑ‰∏äÊòØÂê¶Â≠òÂú®Êù°‰ª∂Âà§Êñ≠ËØ≠Âè•
        
        Êù°‰ª∂Âà§Êñ≠ÁöÑÂ≠óËäÇÁ†ÅÁâπÂæÅÔºö
        - JUMPI: Êù°‰ª∂Ë∑≥ËΩ¨
        - EQ, LT, GT, SLT, SGT: ÊØîËæÉÊìç‰Ωú
        - ISZERO: Èõ∂ÂÄºÊ£ÄÊü•
        - REVERT: ÂõûÊªöÔºàÈÄöÂ∏∏Âú®requireÂ§±Ë¥•ÂêéÔºâ
        
        ËøîÂõû: TrueË°®Á§∫Ë∑ØÂæÑ‰∏äÊúâÊù°‰ª∂Âà§Êñ≠ÔºàÂèØËÉΩÊòØÂÆâÂÖ®ÁöÑÔºâÔºåFalseË°®Á§∫Êó†Êù°‰ª∂Âà§Êñ≠ÔºàÂç±Èô©Ôºâ
        """
        condition_opcodes = {
            'JUMPI',      # Êù°‰ª∂Ë∑≥ËΩ¨Ôºàif/requireÁöÑÊ†∏ÂøÉÔºâ
            'EQ', 'LT', 'GT', 'SLT', 'SGT',  # ÊØîËæÉÊìç‰Ωú
            'ISZERO',     # Èõ∂ÂÄºÊ£ÄÊü•
            'REVERT'      # ÂõûÊªöÔºàrequireÂ§±Ë¥•Ôºâ
        }
        
        # ÈÅçÂéÜË∑ØÂæÑ‰∏äÁöÑÊâÄÊúâÂü∫Êú¨Âùó
        for bb_start in path:
            # ÊâæÂà∞ÂØπÂ∫îÁöÑÂü∫Êú¨Âùó
            block = next((b for b in basic_blocks if b['start'] == bb_start), None)
            if not block:
                continue
            
            # Ê£ÄÊü•Âü∫Êú¨Âùó‰∏≠ÁöÑÊåá‰ª§
            for instr in block['instructions']:
                if instr['op'] in condition_opcodes:
                    return True
        
        return False
    
    def _save_taint_results(self):
        """‰øùÂ≠òÊ±°ÁÇπÂàÜÊûêÁªìÊûú"""
        output_file = os.path.join(self.output_dir, "intermediate", "taint_analysis.jsonl")
        
        with open(output_file, 'w', encoding='utf-8') as f:
            for result in self.taint_results:
                f.write(json.dumps(result, ensure_ascii=False) + '\n')
        
        print(f"  ‚Üí Ê±°ÁÇπÂàÜÊûêÁªìÊûú: {output_file}")


# ============================================================================
# Á¨¨4ÈÉ®ÂàÜÔºöÊ∫êÁ†ÅÊò†Â∞Ñ
# ============================================================================

class SourceMapper:
    """Ê∫êÁ†ÅÊò†Â∞ÑÂô®"""
    
    def __init__(self, source_file: str, output_dir: str):
        self.source_file = source_file
        self.output_dir = output_dir
        self.source_lines = []
        self.function_map = {}
        self._load_and_parse_source()
    
    def _load_and_parse_source(self):
        """Âä†ËΩΩÂπ∂Ëß£ÊûêÊ∫êÁ†Å"""
        with open(self.source_file, 'r', encoding='utf-8') as f:
            self.source_lines = f.readlines()
        
        # ‰∏§Èò∂ÊÆµËß£ÊûêÔºöÂÖàÊâæÊâÄÊúâÂáΩÊï∞ÂÆö‰πâÔºåÂÜçÂàÜÈÖçË°åÂè∑
        function_starts = []  # [(line_num, func_name), ...]
        
        # Èò∂ÊÆµ1ÔºöÊâæÂà∞ÊâÄÊúâÂáΩÊï∞ÂÆö‰πâÔºàÊéíÈô§Ê≥®ÈáäÔºâ
        for line_num, line in enumerate(self.source_lines, 1):
            # ÁßªÈô§Ê≥®ÈáäÂêéÂÜçÂåπÈÖç
            code_part = line.split('//')[0]  # ÁßªÈô§ÂçïË°åÊ≥®Èáä
            func_match = re.search(r'function\s+(\w+|\(\))', code_part)  # ÊîØÊåÅ function() ÂΩ¢Âºè
            if func_match:
                func_name_match = func_match.group(1)
                # Â¶ÇÊûúÊòØ () Âàô‰ΩøÁî®ÁâπÊÆäÂêçÁß∞
                func_name = 'fallback' if func_name_match == '()' else func_name_match
                function_starts.append((line_num, func_name))
        
        # Èò∂ÊÆµ2Ôºö‰∏∫ÊØè‰∏™ÂáΩÊï∞ÂàÜÈÖçË°åÂè∑ËåÉÂõ¥
        for i, (start_line, func_name) in enumerate(function_starts):
            # ÂáΩÊï∞ÁªìÊùü‰ΩçÁΩÆÔºö‰∏ã‰∏Ä‰∏™ÂáΩÊï∞ÂºÄÂßãÁöÑÂâç‰∏ÄË°åÔºåÊàñÊñá‰ª∂ÁªìÊùü
            if i + 1 < len(function_starts):
                end_line = function_starts[i + 1][0] - 1
            else:
                end_line = len(self.source_lines)
            
            # ‰ΩøÁî®Â§ßÊã¨Âè∑ËÆ°Êï∞+Áº©ËøõÂà§Êñ≠Á≤æÁ°ÆÁ°ÆÂÆöÂáΩÊï∞ÁªìÊùü‰ΩçÁΩÆ
            brace_count = 0
            actual_end = end_line
            found_opening_brace = False
            
            # Ëé∑ÂèñÂáΩÊï∞ÂÆö‰πâË°åÁöÑÁº©ËøõÁ∫ßÂà´
            func_def_line = self.source_lines[start_line - 1]
            func_indent = len(func_def_line) - len(func_def_line.lstrip())
            
            for line_num in range(start_line, min(end_line + 1, len(self.source_lines) + 1)):
                line = self.source_lines[line_num - 1]
                
                # Ê£ÄÊü•ÊòØÂê¶ÊúâÂ∑¶Â§ßÊã¨Âè∑ÔºàÂáΩÊï∞‰ΩìÂºÄÂßãÔºâ
                if '{' in line:
                    found_opening_brace = True
                
                brace_count += line.count('{') - line.count('}')
                
                # ÂáΩÊï∞‰ΩìÂÆåÂÖ®Èó≠ÂêàÁöÑÊù°‰ª∂ÔºàÂÖ≥ÈîÆÊîπËøõÔºö‰ΩøÁî®Áº©ËøõÂà§Êñ≠ÔºâÔºö
                # 1. Â∑≤ÁªèÊâæÂà∞ËøáÂ∑¶Â§ßÊã¨Âè∑ÔºàÂáΩÊï∞‰ΩìÂ∑≤ÂºÄÂßãÔºâ
                # 2. ÂΩìÂâçbrace_count==0ÔºàÂ§ßÊã¨Âè∑Â∑≤ÁªèÂÖ®ÈÉ®ÈÖçÂØπÔºâ
                # 3. ÂΩìÂâçË°åÂåÖÂê´Âè≥Â§ßÊã¨Âè∑
                # 4. ÂΩìÂâçË°åÁöÑÁº©Ëøõ <= ÂáΩÊï∞ÂÆö‰πâË°åÁöÑÁº©ËøõÔºàÂêåÁ∫ßÊàñÊõ¥Â§ñÂ±ÇÔºåËØ¥ÊòéÊòØÂáΩÊï∞Á∫ßÂà´ÁöÑ}Ôºâ
                if found_opening_brace and brace_count == 0 and '}' in line and line_num > start_line:
                    line_indent = len(line) - len(line.lstrip())
                    stripped = line.strip()
                    
                    # ÊòØÂáΩÊï∞Á∫ßÂà´ÁöÑ} ÔºàÁº©Ëøõ‰∏éÂáΩÊï∞ÂÆö‰πâÂêåÁ∫ßÊàñÊõ¥Â§ñÂ±ÇÔºâ
                    if (stripped == '}' or stripped.startswith('}')) and line_indent <= func_indent:
                        actual_end = line_num
                        break
            
            self.function_map[func_name] = {
                'start_line': start_line,
                'end_line': actual_end,
                'lines': list(range(start_line, actual_end + 1)),
                'variables_used': []
            }
    
    def map_to_source(self, taint_results: List[Dict], 
                      bytecode_analyzer: BytecodeAnalyzer) -> List[Dict]:
        """Â∞ÜÊ±°ÁÇπÁªìÊûúÊò†Â∞ÑÂà∞Ê∫êÁ†Å"""
        print(f"\n{Colors.HEADER}„ÄêÊ≠•È™§5„ÄëÊ∫êÁ†ÅÊò†Â∞Ñ{Colors.ENDC}")
        print("-" * 80)
        
        mapped_results = []
        
        for taint_result in taint_results:
            var_name = taint_result['name']
            has_taint = len(taint_result['taint_bb']) > 0
            
            # Êü•ÊâæÂèòÈáèÂú®Ê∫êÁ†Å‰∏≠ÁöÑ‰ΩøÁî®
            usages = self._find_variable_usage(var_name)
            
            # ÂàÜÊûêË∑ØÂæÑÁ±ªÂûãÔºàÊñ∞Â¢ûÔºâ
            dangerous_paths = []  # Êó†Êù°‰ª∂Âà§Êñ≠ÁöÑÂç±Èô©Ë∑ØÂæÑ
            suspicious_paths = []  # ÊúâÊù°‰ª∂Âà§Êñ≠ÁöÑÂèØÁñëË∑ØÂæÑ
            
            if has_taint and 'paths_with_conditions' in taint_result:
                for path_info in taint_result['paths_with_conditions']:
                    if path_info['has_condition']:
                        suspicious_paths.append(path_info['path'])
                    else:
                        dangerous_paths.append(path_info['path'])
            
            # Ê†áËÆ∞È£éÈô©‰ΩçÁΩÆÔºàÂå∫ÂàÜÂç±Èô©ÂíåÂèØÁñëÔºâ
            # ÂÖ≥ÈîÆÊîπËøõÔºöÂè™Ê£ÄÊü•ÂÜôÂÖ•Êìç‰ΩúÔºåÊéíÈô§ËØªÂèñÊìç‰ΩúÔºàÂ¶ÇÊù°‰ª∂Âà§Êñ≠‰∏≠ÁöÑÂèòÈáèÔºâ
            dangerous_locations = []
            suspicious_locations = []
            
            # ÊîπËøõ1: Âü∫‰∫éÊ±°ÁÇπÂàÜÊûêÁöÑÊ£ÄÊµãÔºàÂéüÊúâÈÄªËæëÔºâ
            if has_taint:
                for usage in usages:
                    # Ê†∏ÂøÉ‰øÆÂ§çÔºöÂè™ÊúâÂÜôÂÖ•Êìç‰ΩúÊâçÂèØËÉΩÊòØÈ£éÈô©‰ΩçÁΩÆ
                    if usage['operation'] == 'write':
                        # Ê£ÄÊü•ËØ•‰ΩçÁΩÆÂØπÂ∫îÁöÑÊ∫êÁ†ÅÊòØÂê¶ÊúâÊù°‰ª∂Âà§Êñ≠
                        has_condition_in_source = self._check_source_has_condition(usage)
                        
                        location_info = usage.copy()
                        location_info['has_source_condition'] = has_condition_in_source
                        location_info['detection_method'] = 'taint_analysis'
                        
                        # ‰øÆÂ§çÂêéÁöÑÈÄªËæëÔºöÊ∫êÁ†ÅÊúâÊù°‰ª∂‰øùÊä§ ‚Üí ÂèØÁñëÔºåÂê¶Âàô ‚Üí Âç±Èô©
                        if has_condition_in_source:
                            # Ê∫êÁ†ÅÊòéÁ°ÆÊúâÊù°‰ª∂‰øùÊä§Ôºàrequire/if/modifierÔºâ
                            suspicious_locations.append(location_info)
                        else:
                            # Ê∫êÁ†ÅÊó†ÊòéÁ°ÆÊù°‰ª∂‰øùÊä§
                            dangerous_locations.append(location_info)
                    # ËØªÂèñÊìç‰ΩúÔºàÂ¶Ç if (keyHash == 0x0)Ôºâ‰∏ç‰ºöË¢´Ê†áËÆ∞‰∏∫È£éÈô©
            
            # ÊîπËøõ2: Ë°•ÂÖÖÊ£ÄÊµã - publicÂáΩÊï∞ÂÜôÂÖ•ÂÖ≥ÈîÆÂèòÈáè‰ΩÜÊó†ËÆøÈóÆÊéßÂà∂ÔºàÊñ∞Â¢ûÔºâ
            # Âç≥‰ΩøÊ±°ÁÇπÂàÜÊûêÂ§±Ë¥•Ôºå‰πüËÉΩÈÄöËøáÊ≠§Êú∫Âà∂Ê£ÄÊµãÂà∞ÊºèÊ¥û
            for usage in usages:
                if usage['operation'] == 'write':
                    func_name = usage.get('function')
                    if func_name:
                        # Ê£ÄÊü•ÊòØÂê¶ÊòØpublicÂáΩÊï∞‰∏îÊó†ËÆøÈóÆÊéßÂà∂
                        has_ac, reason = self._check_public_function_has_access_control(func_name)
                        
                        if not has_ac:  # publicÂáΩÊï∞Êó†ËÆøÈóÆÊéßÂà∂
                            # Ê£ÄÊü•ÊòØÂê¶Â∑≤ÁªèË¢´Ê†áËÆ∞ÔºàÈÅøÂÖçÈáçÂ§çÔºâ
                            already_flagged = any(
                                loc['line'] == usage['line'] and loc['function'] == func_name
                                for loc in dangerous_locations + suspicious_locations
                            )
                            
                            if not already_flagged:
                                location_info = usage.copy()
                                location_info['has_source_condition'] = False
                                location_info['detection_method'] = 'public_function_check'
                                location_info['warning'] = f"‚ö†Ô∏è {reason}"
                                dangerous_locations.append(location_info)
            
            # ÈáçÊñ∞ËÆ°ÁÆóÔºöÂ¶ÇÊûúË°•ÂÖÖÊ£ÄÊµãÂèëÁé∞‰∫ÜÂç±Èô©‰ΩçÁΩÆÔºå‰πüÂ∫îÊ†áËÆ∞‰∏∫ÊúâÊºèÊ¥û
            has_vulnerability = has_taint or len(dangerous_locations) > 0 or len(suspicious_locations) > 0
            
            mapped = {
                'variable': var_name,
                'storage_slot': taint_result['offset'],
                'has_taint': has_taint,
                'has_vulnerability': has_vulnerability,  # Êñ∞Â¢ûÔºöÁªºÂêàÂà§Êñ≠
                'taint_paths_count': len(taint_result['taint_cfg']),
                'dangerous_paths_count': len(dangerous_paths),  # Êñ∞Â¢û
                'suspicious_paths_count': len(suspicious_paths),  # Êñ∞Â¢û
                'affected_basic_blocks': taint_result['taint_bb'],
                'source_usages': usages,
                'dangerous_locations': dangerous_locations,  # Êñ∞Â¢ûÔºöÂç±Èô©‰ΩçÁΩÆÔºàÊó†‰øùÊä§Ôºâ
                'suspicious_locations': suspicious_locations,  # Êñ∞Â¢ûÔºöÂèØÁñë‰ΩçÁΩÆÔºàÊúâ‰øùÊä§Ôºâ
                'risk_locations': dangerous_locations + suspicious_locations  # ‰øùÊåÅÂÖºÂÆπÊÄß
            }
            
            mapped_results.append(mapped)
        
        print(f"{Colors.GREEN}‚úì Ê∫êÁ†ÅÊò†Â∞ÑÂÆåÊàê{Colors.ENDC}")
        print(f"  - Êò†Â∞ÑÂèòÈáè: {len(mapped_results)} ‰∏™")
        
        # ‰øùÂ≠òÁªìÊûú
        self._save_mapped_results(mapped_results)
        
        return mapped_results
    
    def _find_variable_usage(self, var_name: str) -> List[Dict]:
        """Êü•ÊâæÂèòÈáè‰ΩøÁî®‰ΩçÁΩÆ"""
        usages = []
        
        for line_num, line in enumerate(self.source_lines, 1):
            if re.search(rf'\b{var_name}\b', line):
                usage_type = 'declaration' if any(kw in line for kw in 
                    ['uint', 'address', 'bool', 'mapping', 'string']) else 'usage'
                
                # ÊîπËøõÁöÑÊìç‰ΩúÁ±ªÂûãËØÜÂà´
                operation = self._determine_operation_type(line, var_name)
                
                usages.append({
                    'line': line_num,
                    'code': line.strip(),
                    'type': usage_type,
                    'operation': operation,
                    'function': self._find_function_for_line(line_num)
                })
        
        return usages
    
    def _determine_operation_type(self, line: str, var_name: str) -> str:
        """
        ÂáÜÁ°ÆÂà§Êñ≠ÂèòÈáèÊìç‰ΩúÁ±ªÂûã
        
        ÂÜôÂÖ•Êìç‰ΩúÁâπÂæÅÔºö
        - varName = value (ËµãÂÄº)
        - varName += value (Â§çÂêàËµãÂÄº)
        - varName++ / ++varName (Ëá™Â¢û)
        
        ËØªÂèñÊìç‰ΩúÁâπÂæÅÔºà‰∏çÂ∫îÊ†áËÆ∞‰∏∫È£éÈô©ÔºâÔºö
        - if (varName == ...) (Êù°‰ª∂Âà§Êñ≠)
        - require(varName != ...) (Êù°‰ª∂Ê£ÄÊü•)
        - return varName (ËøîÂõûÂÄº)
        - function(varName) (ÂáΩÊï∞ÂèÇÊï∞)
        """
        # ÁßªÈô§Ê≥®Èáä
        code_part = line.split('//')[0].strip()
        
        # ‰ºòÂÖàÁ∫ß1: Ê£ÄÊü•ÂÜôÂÖ•Êìç‰ΩúÔºàËµãÂÄºÔºâ- ÂøÖÈ°ªÂÖàÊ£ÄÊü•ÔºåÂõ†‰∏∫ËµãÂÄºÊòØÊúÄÊòéÁ°ÆÁöÑÂÜôÂÖ•
        # ÂåπÈÖç varName = value Êàñ varName += value Á≠â
        # Ê≥®ÊÑèÔºöË¶ÅÊéíÈô§ÊØîËæÉÊìç‰Ωú (==, !=, >=, <=)
        assignment_pattern = rf'\b{re.escape(var_name)}\b\s*(=|[\+\-\*/%&|\^]=|<<=|>>=)\s*'
        if re.search(assignment_pattern, code_part):
            # ÂÜçÊ¨°Á°ÆËÆ§‰∏çÊòØÊØîËæÉÊìç‰Ωú (==, !=, >=, <=)
            comparison_pattern = rf'\b{re.escape(var_name)}\b\s*(==|!=|>=|<=)\s*'
            if not re.search(comparison_pattern, code_part):
                # Á°ÆËÆ§ÊòØËµãÂÄºÊìç‰ΩúÔºàÂÜôÂÖ•Ôºâ
                return 'write'
        
        # ‰ºòÂÖàÁ∫ß2: Ê£ÄÊü•Ëá™Â¢û/Ëá™ÂáèÊìç‰ΩúÔºàÂÜôÂÖ•Ôºâ
        if re.search(rf'(\+\+{re.escape(var_name)}|{re.escape(var_name)}\+\+|--{re.escape(var_name)}|{re.escape(var_name)}--)', code_part):
            return 'write'
        
        # ‰ºòÂÖàÁ∫ß3: Ê£ÄÊü•ÊòØÂê¶Âú®Êù°‰ª∂Âà§Êñ≠‰∏≠ÔºàËØªÂèñÊìç‰ΩúÔºâ
        if any(keyword in code_part for keyword in [
            'if (', 'if(', 
            'require(', 'require (', 
            'assert(', 'assert (',
            'return ', 'return(',
        ]):
            # Âú®Êù°‰ª∂Âà§Êñ≠/ËøîÂõûËØ≠Âè•‰∏≠ÁöÑ‰ΩøÁî®ÈÉΩÊòØËØªÂèñ
            return 'read'
        
        # ‰ºòÂÖàÁ∫ß4: Ê£ÄÊü•ÊòØÂê¶ÊòØÊØîËæÉÊìç‰ΩúÔºàËØªÂèñÊìç‰ΩúÔºâ
        # ÂåπÈÖç varName == / != / > / < / >= / <= Á≠âÊØîËæÉÊìç‰Ωú
        comparison_pattern = rf'\b{re.escape(var_name)}\b\s*(==|!=|>|<|>=|<=)\s*'
        if re.search(comparison_pattern, code_part):
            return 'read'
        
        # ‰ºòÂÖàÁ∫ß5: Ê£ÄÊü•ÂáΩÊï∞Ë∞ÉÁî®‰∏≠‰Ωú‰∏∫ÂèÇÊï∞ÔºàËØªÂèñÔºâ
        # ‰æãÂ¶Ç: someFunction(varName)
        func_call_pattern = rf'\w+\([^)]*\b{re.escape(var_name)}\b[^)]*\)'
        if re.search(func_call_pattern, code_part):
            return 'read'
        
        # ‰ºòÂÖàÁ∫ß6: Ê£ÄÊü•ÊòØÂê¶Âú®Á≠âÂè∑Âè≥ËæπÔºàËØªÂèñÊìç‰ΩúÔºâ
        # ‰æãÂ¶Ç: otherVar = varName + 1
        if '=' in code_part:
            parts = code_part.split('=')
            if len(parts) >= 2:
                left_side = parts[0]
                right_side = '='.join(parts[1:])
                
                # ÂèòÈáèÂè™Âú®Âè≥ËæπÂá∫Áé∞ÔºàËØªÂèñÔºâ
                if var_name not in left_side and var_name in right_side:
                    return 'read'
        
        # ÈªòËÆ§‰∏∫ËØªÂèñÔºà‰øùÂÆàÁ≠ñÁï•ÔºåÈÅøÂÖçËØØÊä•Ôºâ
        return 'read'
    
    def _find_function_for_line(self, line_num: int) -> Optional[str]:
        """ÊâæÂà∞Ë°åÊâÄÂ±ûÁöÑÂáΩÊï∞"""
        for func_name, func_info in self.function_map.items():
            if line_num in func_info['lines']:
                return func_name
        return None
    
    def _check_public_function_has_access_control(self, func_name: str):
        """
        Ê£ÄÊü•publicÂáΩÊï∞ÊòØÂê¶ÊúâËÆøÈóÆÊéßÂà∂ÔºàÊñ∞Â¢ûÂäüËÉΩÔºâ
        
        ËøîÂõû: (has_control, reason)
        - has_control: TrueË°®Á§∫ÊúâËÆøÈóÆÊéßÂà∂ÔºåFalseË°®Á§∫Êó†‰øùÊä§
        - reason: ËØ¥ÊòéÂéüÂõ†
        """
        if not func_name:
            return False, "Êú™Áü•ÂáΩÊï∞"
        
        # Ê£ÄÊü•ÂáΩÊï∞ÂÆö‰πâ
        for line in self.source_lines:
            if f'function {func_name}' in line:
                # Ê£ÄÊü•ÊòØÂê¶ÊòØpublic/externalÂáΩÊï∞
                if 'public' not in line and 'external' not in line:
                    return True, "ÈùûpublicÂáΩÊï∞"
                
                # Ê£ÄÊü•ÊòØÂê¶ÊúâËÆøÈóÆÊéßÂà∂modifier
                if any(modifier in line for modifier in [
                    'onlyOwner', 'onlyAdmin', 'only', 'ownerOnly',
                    'whenNotPaused', 'nonReentrant'
                ]):
                    return True, f"ÊúâËÆøÈóÆÊéßÂà∂modifier"
        
        # Ê£ÄÊü•ÂáΩÊï∞‰ΩìÂÜÖÊòØÂê¶ÊúâËÆøÈóÆÊéßÂà∂
        func_lines = self.function_map.get(func_name, {}).get('lines', [])
        access_control_patterns = ['msg.sender', 'tx.origin', 'owner', 'admin']
        
        for func_line_num in func_lines:
            if 0 <= func_line_num - 1 < len(self.source_lines):
                line = self.source_lines[func_line_num - 1]
                
                if any(keyword in line for keyword in ['require(', 'require ', 'assert(']):
                    if any(pattern in line for pattern in access_control_patterns):
                        return True, f"ÊúârequireËÆøÈóÆÊéßÂà∂"
        
        return False, "publicÂáΩÊï∞Êó†ËÆøÈóÆÊéßÂà∂"
    
    def _check_source_has_condition(self, usage: Dict) -> bool:
        """
        Ê£ÄÊü•Ê∫êÁ†Å‰ΩçÁΩÆÊòØÂê¶Êúâ**ËÆøÈóÆÊéßÂà∂**Êù°‰ª∂ÔºàËÄåÈùûÊôÆÈÄöÁä∂ÊÄÅÊ£ÄÊü•Ôºâ
        
        ÂÖ≥ÈîÆÊîπËøõÔºöÂå∫ÂàÜËÆøÈóÆÊéßÂà∂ vs Áä∂ÊÄÅÊ£ÄÊü•
        
        ‚úÖ ËÆøÈóÆÊéßÂà∂ÔºàËøîÂõûTrueÔºâÔºö
        - require(msg.sender == owner): Ê£ÄÊü•Ë∞ÉÁî®ËÄÖË∫´‰ªΩ
        - modifier onlyOwner: ËÆøÈóÆÊéßÂà∂‰øÆÈ•∞Âô®
        - if (msg.sender == ...): Ë∞ÉÁî®ËÄÖÊ£ÄÊü•
        
        ‚ùå Áä∂ÊÄÅÊ£ÄÊü•ÔºàËøîÂõûFalseÔºå‰∏çÊòØÁúüÊ≠£ÁöÑ‰øùÊä§ÔºâÔºö
        - if (keyHash == 0x0): Âè™ÊòØÊ£ÄÊü•ÂèòÈáèÂÄº
        - if (balance > 0): Âè™ÊòØÁä∂ÊÄÅÂà§Êñ≠
        
        ËøîÂõû: TrueË°®Á§∫ÊúâËÆøÈóÆÊéßÂà∂‰øùÊä§ÔºåFalseË°®Á§∫Êó†‰øùÊä§
        """
        line_num = usage['line']
        func_name = usage.get('function')
        
        # ‰ºòÂÖàÁ∫ß1: Ê£ÄÊü•ÂáΩÊï∞ÊòØÂê¶ÊúâËÆøÈóÆÊéßÂà∂modifier
        if func_name:
            for line in self.source_lines:
                if f'function {func_name}' in line:
                    # Ê£ÄÊü•Â∏∏ËßÅÁöÑËÆøÈóÆÊéßÂà∂modifier
                    if any(modifier in line for modifier in [
                        'onlyOwner', 'onlyAdmin', 'only',
                        'whenNotPaused', 'whenPaused',
                        'nonReentrant', 'ownerOnly'
                    ]):
                        return True
        
        # ‰ºòÂÖàÁ∫ß2: Ê£ÄÊü•ÂáΩÊï∞ÂÜÖÊòØÂê¶ÊúâËÆøÈóÆÊéßÂà∂Áõ∏ÂÖ≥ÁöÑÊù°‰ª∂Âà§Êñ≠
        # ÂÖ≥ÈîÆÔºöÂøÖÈ°ªÊ£ÄÊü• msg.sender Êàñ tx.origin
        access_control_patterns = [
            'msg.sender',   # Ë∞ÉÁî®ËÄÖÊ£ÄÊü•
            'tx.origin',    # ÂéüÂßãË∞ÉÁî®ËÄÖÊ£ÄÊü•
            'owner',        # ÊâÄÊúâËÄÖÊ£ÄÊü•ÔºàÈÄöÂ∏∏‰∏émsg.senderÈÖçÂêàÔºâ
            'admin',        # ÁÆ°ÁêÜÂëòÊ£ÄÊü•
            'authorized',   # ÊéàÊùÉÊ£ÄÊü•
        ]
        
        if func_name:
            func_lines = self.function_map.get(func_name, {}).get('lines', [])
            if func_lines:
                for func_line_num in func_lines:
                    # Âè™Ê£ÄÊü•ÂΩìÂâçÂÜôÂÖ•Ë°å‰πãÂâçÁöÑË°åÔºàÊù°‰ª∂‰øùÊä§Â∫îËØ•Âú®ËµãÂÄº‰πãÂâçÔºâ
                    if func_line_num >= line_num:
                        continue
                    
                    if 0 <= func_line_num - 1 < len(self.source_lines):
                        line = self.source_lines[func_line_num - 1]
                        
                        # Ê£ÄÊü•ÊòØÂê¶ÊòØËÆøÈóÆÊéßÂà∂Áõ∏ÂÖ≥ÁöÑÊù°‰ª∂
                        if any(keyword in line for keyword in [
                            'require(', 'require (', 
                            'assert(', 'assert (',
                            'revert(', 'revert ('
                        ]):
                            # Ëøõ‰∏ÄÊ≠•Ê£ÄÊü•ÊòØÂê¶ÂåÖÂê´ËÆøÈóÆÊéßÂà∂Ê®°Âºè
                            if any(pattern in line for pattern in access_control_patterns):
                                return True
                        
                        # Ê£ÄÊü• if ËØ≠Âè•ÊòØÂê¶ÂåÖÂê´ËÆøÈóÆÊéßÂà∂
                        if 'if (' in line or 'if(' in line:
                            if any(pattern in line for pattern in access_control_patterns):
                                return True
        
        # ‰ºòÂÖàÁ∫ß3: Ê£ÄÊü•ÂΩìÂâçË°åÂâçÂá†Ë°åÊòØÂê¶ÊúâËÆøÈóÆÊéßÂà∂
        check_range = 5  # Âè™Ê£ÄÊü•Ââç5Ë°åÔºàÊù°‰ª∂‰øùÊä§Â∫îËØ•Á¥ßÈÇªËµãÂÄºËØ≠Âè•Ôºâ
        
        for i in range(max(0, line_num - 1 - check_range), line_num - 1):
            if i < len(self.source_lines):
                line = self.source_lines[i]
                
                # Âè™Ê£ÄÊü•ËÆøÈóÆÊéßÂà∂Áõ∏ÂÖ≥ÁöÑÊù°‰ª∂
                if any(keyword in line for keyword in [
                    'require(', 'require (', 
                    'assert(', 'assert ('
                ]):
                    if any(pattern in line for pattern in access_control_patterns):
                        return True
        
        return False
    
    def _save_mapped_results(self, results: List[Dict]):
        """‰øùÂ≠òÊò†Â∞ÑÁªìÊûú"""
        output_file = os.path.join(self.output_dir, "intermediate", "source_mapping.json")
        
        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump(results, f, indent=2, ensure_ascii=False)
        
        print(f"  ‚Üí Ê∫êÁ†ÅÊò†Â∞ÑÁªìÊûú: {output_file}")


# ============================================================================
# Á¨¨5ÈÉ®ÂàÜÔºöÊä•ÂëäÁîüÊàê
# ============================================================================

class ReportGenerator:
    """Êä•ÂëäÁîüÊàêÂô®"""
    
    def __init__(self, output_dir: str, source_file: str):
        self.output_dir = output_dir
        self.source_file = source_file
        self.source_lines = []
        
        with open(source_file, 'r', encoding='utf-8') as f:
            self.source_lines = f.readlines()
    
    def generate(self, mapped_results: List[Dict]) -> Dict:
        """ÁîüÊàêÂÆåÊï¥Êä•Âëä"""
        print(f"\n{Colors.HEADER}„ÄêÊ≠•È™§6„ÄëÁîüÊàêÊä•Âëä{Colors.ENDC}")
        print("=" * 80)
        
        # ‰ΩøÁî® has_vulnerability ËÄå‰∏çÊòØÂè™Áúã has_taint
        vulnerable_count = sum(1 for r in mapped_results if r.get('has_vulnerability', r['has_taint']))
        
        # ÁªàÁ´ØÊä•Âëä
        self._print_terminal_report(mapped_results, vulnerable_count)
        
        # JSONÊä•Âëä
        report = {
            'analysis_time': datetime.now().isoformat(),
            'source_file': self.source_file,
            'summary': {
                'total_variables': len(mapped_results),
                'vulnerable_variables': vulnerable_count,
                'safe_variables': len(mapped_results) - vulnerable_count
            },
            'results': mapped_results
        }
        
        # ‰øùÂ≠òÊúÄÁªàÊä•Âëä
        final_report_path = os.path.join(self.output_dir, "final_report.json")
        with open(final_report_path, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
        
        print(f"\n{Colors.BLUE}üíæ ÊúÄÁªàÊä•ÂëäÂ∑≤‰øùÂ≠ò:{Colors.ENDC}")
        print(f"   {final_report_path}")
        
        # ÁîüÊàêHTMLÊä•ÂëäÔºàÂèØÈÄâÔºâ
        html_report_path = os.path.join(self.output_dir, "final_report.html")
        self._generate_html_report(report, html_report_path)
        print(f"   {html_report_path}")
        
        return report
    
    def _print_terminal_report(self, results: List[Dict], vulnerable_count: int):
        """ÊâìÂç∞ÁªàÁ´ØÊä•Âëä"""
        print(f"\n{Colors.BOLD}ÂàÜÊûêÊ¶ÇË¶Å:{Colors.ENDC}")
        print(f"  ÊÄªÂèòÈáèÊï∞: {len(results)}")
        print(f"  Ê£ÄÊµãÂà∞ÊºèÊ¥û: {Colors.RED}{vulnerable_count}{Colors.ENDC}")
        print(f"  ÂÆâÂÖ®ÂèòÈáè: {Colors.GREEN}{len(results) - vulnerable_count}{Colors.ENDC}")
        
        print(f"\n{Colors.BOLD}ËØ¶ÁªÜÁªìÊûú:{Colors.ENDC}")
        print("=" * 80)
        
        for idx, result in enumerate(results, 1):
            var_name = result['variable']
            has_taint = result['has_taint']
            has_vulnerability = result.get('has_vulnerability', has_taint)
            
            status_color = Colors.RED if has_vulnerability else Colors.GREEN
            status_icon = "‚ö†Ô∏è " if has_vulnerability else "‚úÖ"
            
            # ÊòæÁ§∫Ê£ÄÊµãÊñπÊ≥ï
            if has_vulnerability:
                if has_taint:
                    status_text = "Ê£ÄÊµãÂà∞Ê±°ÁÇπ‰º†Êí≠"
                else:
                    status_text = "Ê£ÄÊµãÂà∞ËÆøÈóÆÊéßÂà∂ÊºèÊ¥ûÔºàË°•ÂÖÖÊ£ÄÊµãÔºâ"
            else:
                status_text = "Êú™Ê£ÄÊµãÂà∞ÊºèÊ¥û"
            
            print(f"\n{Colors.BOLD}[{idx}] ÂèòÈáè: {var_name}{Colors.ENDC}")
            print(f"    Áä∂ÊÄÅ: {status_color}{status_icon}{status_text}{Colors.ENDC}")
            print(f"    Â≠òÂÇ®ÊßΩ‰Ωç: {result['storage_slot']}")
            
            if has_taint:
                print(f"    Ê±°ÁÇπË∑ØÂæÑÊï∞: {result['taint_paths_count']}")
                
                # ÊòæÁ§∫Ë∑ØÂæÑÁ±ªÂûãÁªüËÆ°ÔºàÊñ∞Â¢ûÔºâ
                if 'dangerous_paths_count' in result and 'suspicious_paths_count' in result:
                    dangerous_count = result['dangerous_paths_count']
                    suspicious_count = result['suspicious_paths_count']
                    print(f"      ‚îú‚îÄ {Colors.RED}Âç±Èô©Ë∑ØÂæÑ: {dangerous_count} Êù°{Colors.ENDC} (Êó†Êù°‰ª∂‰øùÊä§)")
                    print(f"      ‚îî‚îÄ {Colors.YELLOW}ÂèØÁñëË∑ØÂæÑ: {suspicious_count} Êù°{Colors.ENDC} (ÊúâÊù°‰ª∂Âà§Êñ≠)")
                
                print(f"    ÂèóÂΩ±ÂìçÁöÑÂü∫Êú¨Âùó: {result['affected_basic_blocks']}")
            
            # Ê∫êÁ†Å‰ΩøÁî®‰ΩçÁΩÆÔºàÂå∫ÂàÜËØªÂÜôÊìç‰ΩúÔºâ
            if result['source_usages']:
                write_usages = [u for u in result['source_usages'] if u['operation'] == 'write']
                read_usages = [u for u in result['source_usages'] if u['operation'] == 'read']
                
                print(f"\n    {Colors.CYAN}üìÑ Ê∫êÁ†Å‰∏≠ÁöÑ‰ΩøÁî®‰ΩçÁΩÆ:{Colors.ENDC}")
                print(f"       ÊÄªËÆ°: {len(result['source_usages'])} Â§Ñ (‚úèÔ∏è  ÂÜôÂÖ•: {len(write_usages)}, üëÅÔ∏è  ËØªÂèñ: {len(read_usages)})")
                
                # ‰ºòÂÖàÊòæÁ§∫ÂÜôÂÖ•Êìç‰ΩúÔºàÊõ¥ÈáçË¶ÅÔºâ
                if write_usages:
                    print(f"\n       {Colors.YELLOW}ÂÜôÂÖ•Êìç‰Ωú:{Colors.ENDC}")
                    for usage in write_usages[:3]:
                        func_info = f" (Âú®ÂáΩÊï∞ {usage['function']})" if usage['function'] else ""
                        print(f"       ‚úèÔ∏è  Ë°å {usage['line']:3d}: {usage['code']}{func_info}")
                    if len(write_usages) > 3:
                        print(f"       ... ËøòÊúâ {len(write_usages) - 3} ‰∏™ÂÜôÂÖ•‰ΩçÁΩÆ")
                
                # ÁÑ∂ÂêéÊòæÁ§∫ËØªÂèñÊìç‰ΩúÔºàÂèÇËÄÉ‰ø°ÊÅØÔºâ
                if read_usages:
                    print(f"\n       {Colors.CYAN}ËØªÂèñÊìç‰Ωú (‰∏çÊòØÈ£éÈô©ÁÇπ):{Colors.ENDC}")
                    for usage in read_usages[:2]:
                        func_info = f" (Âú®ÂáΩÊï∞ {usage['function']})" if usage['function'] else ""
                        print(f"       üëÅÔ∏è  Ë°å {usage['line']:3d}: {usage['code']}{func_info}")
                    if len(read_usages) > 2:
                        print(f"       ... ËøòÊúâ {len(read_usages) - 2} ‰∏™ËØªÂèñ‰ΩçÁΩÆ")
            
            # Âç±Èô©‰ΩçÁΩÆÔºàÊñ∞Â¢ûÔºåÈáçÁÇπÊ†áËÆ∞Ôºâ
            if result.get('dangerous_locations'):
                print(f"\n    {Colors.RED}üî• Âç±Èô©‰ΩçÁΩÆÔºàÊó†Êù°‰ª∂‰øùÊä§ÔºåÈúÄÁ´ãÂç≥‰øÆÂ§çÔºâ:{Colors.ENDC}")
                for risk in result['dangerous_locations']:
                    func_name = risk['function'] or 'Êú™Áü•ÂáΩÊï∞'
                    detection_method = risk.get('detection_method', 'taint_analysis')
                    warning = risk.get('warning', '')
                    
                    print(f"       {Colors.RED}‚õî Ë°å {risk['line']:3d} ({func_name}): {risk['code']}{Colors.ENDC}")
                    
                    # ÊòæÁ§∫Ê£ÄÊµãÊñπÊ≥ï
                    if detection_method == 'public_function_check':
                        print(f"          {Colors.YELLOW}üîç Ê£ÄÊµãÊñπÂºè: Ë°•ÂÖÖÊ£ÄÊµãÔºàpublicÂáΩÊï∞Êó†ËÆøÈóÆÊéßÂà∂Ôºâ{Colors.ENDC}")
                    else:
                        print(f"          üîç Ê£ÄÊµãÊñπÂºè: Ê±°ÁÇπÂàÜÊûê")
                    
                    # ÊòæÁ§∫Ë≠¶Âëä‰ø°ÊÅØ
                    if warning:
                        print(f"          {warning}")
                    
                    # ‰∏ä‰∏ãÊñá
                    line_idx = risk['line'] - 1
                    if line_idx > 0:
                        print(f"          ‰∏äÊñá: {self.source_lines[line_idx - 1].strip()}")
                    if line_idx < len(self.source_lines) - 1:
                        print(f"          ‰∏ãÊñá: {self.source_lines[line_idx + 1].strip()}")
            
            # ÂèØÁñë‰ΩçÁΩÆÔºàÊñ∞Â¢ûÔºåÈúÄË¶Å‰∫∫Â∑•ÂÆ°Êü•Ôºâ
            if result.get('suspicious_locations'):
                print(f"\n    {Colors.YELLOW}‚ö†Ô∏è  ÂèØÁñë‰ΩçÁΩÆÔºàÊ£ÄÊµãÂà∞Êù°‰ª∂Âà§Êñ≠ÔºåÂª∫ËÆÆ‰∫∫Â∑•ÂÆ°Êü•Ôºâ:{Colors.ENDC}")
                for risk in result['suspicious_locations']:
                    func_name = risk['function'] or 'Êú™Áü•ÂáΩÊï∞'
                    has_condition = risk.get('has_source_condition', False)
                    condition_mark = " ‚úì" if has_condition else ""
                    print(f"       {Colors.YELLOW}‚ö° Ë°å {risk['line']:3d} ({func_name}): {risk['code']}{condition_mark}{Colors.ENDC}")
                    
                    if has_condition:
                        print(f"          {Colors.GREEN}‚Ü≥ Ê£ÄÊµãÂà∞Êù°‰ª∂‰øùÊä§Ôºàrequire/if/modifierÔºâ{Colors.ENDC}")
                    
                    # ‰∏ä‰∏ãÊñá
                    line_idx = risk['line'] - 1
                    if line_idx > 0:
                        print(f"          ‰∏äÊñá: {self.source_lines[line_idx - 1].strip()}")
                    if line_idx < len(self.source_lines) - 1:
                        print(f"          ‰∏ãÊñá: {self.source_lines[line_idx + 1].strip()}")
        
        print("\n" + "=" * 80)
        
        # ÂÆâÂÖ®Âª∫ËÆÆ
        self._print_security_advice(results)
    
    def _print_security_advice(self, results: List[Dict]):
        """ÊâìÂç∞ÂÆâÂÖ®Âª∫ËÆÆ"""
        vulnerable = [r for r in results if r['has_taint']]
        
        if not vulnerable:
            print(f"\n{Colors.GREEN}‚úÖ ÂÆâÂÖ®ËØÑ‰º∞:{Colors.ENDC}")
            print("   Êú™Ê£ÄÊµãÂà∞ÊòéÊòæÁöÑÊ±°ÁÇπ‰º†Êí≠È£éÈô©")
            print("   Ê≥®ÊÑèÔºö‰ªçÂª∫ËÆÆËøõË°åÂÖ®Èù¢ÁöÑÂÆâÂÖ®ÂÆ°ËÆ°")
            return
        
        # ÂàÜÁ±ªÁªüËÆ°ÔºàÊñ∞Â¢ûÔºâ
        dangerous_vars = [r for r in vulnerable if r.get('dangerous_locations')]
        suspicious_vars = [r for r in vulnerable if r.get('suspicious_locations') and not r.get('dangerous_locations')]
        
        print(f"\n{Colors.YELLOW}‚ö†Ô∏è  ÂÆâÂÖ®Âª∫ËÆÆ:{Colors.ENDC}")
        print("-" * 80)
        
        # ‰ºòÂÖàÊòæÁ§∫Âç±Èô©ÂèòÈáè
        if dangerous_vars:
            print(f"\n{Colors.RED}{Colors.BOLD}üî• È´òÂç±Èô©ÂèòÈáèÔºàÈúÄÁ´ãÂç≥‰øÆÂ§çÔºâ:{Colors.ENDC}")
            for result in dangerous_vars:
                var_name = result['variable']
                dangerous_count = len(result.get('dangerous_locations', []))
                print(f"\n{Colors.BOLD}ÂèòÈáè '{var_name}' ({dangerous_count} ‰∏™Âç±Èô©‰ΩçÁΩÆ):{Colors.ENDC}")
                self._print_variable_advice(var_name, is_dangerous=True)
        
        # ÁÑ∂ÂêéÊòæÁ§∫ÂèØÁñëÂèòÈáè
        if suspicious_vars:
            print(f"\n{Colors.YELLOW}{Colors.BOLD}‚ö†Ô∏è  ÂèØÁñëÂèòÈáèÔºàÂª∫ËÆÆ‰∫∫Â∑•ÂÆ°Êü•Ôºâ:{Colors.ENDC}")
            for result in suspicious_vars:
                var_name = result['variable']
                suspicious_count = len(result.get('suspicious_locations', []))
                print(f"\n{Colors.BOLD}ÂèòÈáè '{var_name}' ({suspicious_count} ‰∏™ÂèØÁñë‰ΩçÁΩÆ):{Colors.ENDC}")
                self._print_variable_advice(var_name, is_dangerous=False)
    
    def _print_variable_advice(self, var_name: str, is_dangerous: bool):
        """ÊâìÂç∞ÂèòÈáèÁöÑÂÖ∑‰ΩìÂª∫ËÆÆ"""
        if is_dangerous:
            priority = f"{Colors.RED}„ÄêÁ¥ßÊÄ•‰øÆÂ§ç„Äë{Colors.ENDC}"
            urgency_note = f"  {Colors.RED}‚ö†Ô∏è  Ê≠§ÂèòÈáèÊó†Êù°‰ª∂‰øùÊä§ÔºåÂ≠òÂú®Áõ¥Êé•Âà©Áî®È£éÈô©ÔºÅ{Colors.ENDC}\n"
        else:
            priority = f"{Colors.YELLOW}„Äê‰∫∫Â∑•ÂÆ°Êü•„Äë{Colors.ENDC}"
            urgency_note = f"  {Colors.GREEN}‚úì Â∑≤Ê£ÄÊµãÂà∞Êù°‰ª∂Âà§Êñ≠Ôºå‰ΩÜ‰ªçÈúÄÁ°ÆËÆ§‰øùÊä§ÊòØÂê¶ÂÖÖÂàÜ{Colors.ENDC}\n"
        
        print(f"  {priority}")
        print(urgency_note)
        
        var_name_lower = var_name.lower()
        
        if 'owner' in var_name_lower:
            print("  ËøôÊòØÊùÉÈôêÊéßÂà∂ÂèòÈáèÔºåÂª∫ËÆÆ:")
            if is_dangerous:
                print(f"  {Colors.RED}‚úó ÂΩìÂâçÁä∂ÊÄÅÔºö‰ªª‰Ωï‰∫∫ÈÉΩÂèØ‰ª•‰øÆÊîπÊ≠§ÂèòÈáèÔºÅ{Colors.ENDC}")
            print("  1. ‰ΩøÁî® modifier onlyOwner ‰øùÊä§ÊâÄÊúâ‰øÆÊîπownerÁöÑÂáΩÊï∞")
            print("  2. ËÄÉËôëÂÆûÁé∞‰∏§Ê≠•ËΩ¨ÁßªÊú∫Âà∂ÔºàtransferOwnership + acceptOwnershipÔºâ")
            print("  3. ‰∏∫ÊùÉÈôêÂèòÊõ¥Ê∑ªÂä†‰∫ã‰ª∂Êó•Âøó")
            print("\n  Á§∫‰æã‰ª£Á†Å:")
            print("    modifier onlyOwner() { require(msg.sender == owner); _; }")
            print("    function changeOwner(address newOwner) public onlyOwner { ... }")
        
        elif 'balance' in var_name_lower or 'supply' in var_name_lower:
            print("  ËøôÊòØËµÑÈáëÁõ∏ÂÖ≥ÂèòÈáèÔºåÂª∫ËÆÆ:")
            if is_dangerous:
                print(f"  {Colors.RED}‚úó ÂΩìÂâçÁä∂ÊÄÅÔºöËµÑÈáëÂèØËÉΩË¢´‰ªªÊÑèÊìçÊéßÔºÅ{Colors.ENDC}")
            print("  1. ‰ΩøÁî® Checks-Effects-Interactions Ê®°Âºè")
            print("  2. Âú®Â§ñÈÉ®Ë∞ÉÁî®ÂâçÊõ¥Êñ∞Áä∂ÊÄÅ")
            print("  3. ËÄÉËôë‰ΩøÁî® SafeMath Èò≤Ê≠¢Ê∫¢Âá∫")
            print("  4. Ê∑ªÂä†ÊèêÁé∞ÈôêÈ¢ùÂíåÂÜ∑Âç¥Êúü")
        
        elif any(kw in var_name_lower for kw in ['auth', 'admin', 'pause']):
            print("  ËøôÊòØÊéßÂà∂ÂèòÈáèÔºåÂª∫ËÆÆ:")
            if is_dangerous:
                print(f"  {Colors.RED}‚úó ÂΩìÂâçÁä∂ÊÄÅÔºöÂêàÁ∫¶ÊéßÂà∂ÊùÉÂèØËÉΩË¢´Â§∫ÂèñÔºÅ{Colors.ENDC}")
            print("  1. Ê∑ªÂä†ÈÄÇÂΩìÁöÑËÆøÈóÆÊéßÂà∂")
            print("  2. ‰ΩøÁî® OpenZeppelin ÁöÑ Ownable/AccessControl")
            print("  3. ‰∏∫Áä∂ÊÄÅÂèòÊõ¥Ê∑ªÂä†‰∫ã‰ª∂")
        
        else:
            print("  ÈÄöÁî®Âª∫ËÆÆ:")
            if is_dangerous:
                print(f"  {Colors.RED}‚úó ÂΩìÂâçÁä∂ÊÄÅÔºöÂèòÈáèÂèØË¢´‰ªªÊÑè‰øÆÊîπÔºÅ{Colors.ENDC}")
            print("  1. Ê£ÄÊü•ÊâÄÊúâ‰øÆÊîπÊ≠§ÂèòÈáèÁöÑÂáΩÊï∞ÊòØÂê¶ÊúâËÆøÈóÆÊéßÂà∂")
            print("  2. È™åËØÅÊâÄÊúâÂ§ñÈÉ®ËæìÂÖ•")
            print("  3. Ê∑ªÂä†ÂøÖË¶ÅÁöÑ require Ê£ÄÊü•")
        
        if not is_dangerous:
            print(f"\n  {Colors.CYAN}ÊèêÁ§∫ÔºöËôΩÁÑ∂Ê£ÄÊµãÂà∞Êù°‰ª∂Âà§Êñ≠Ôºå‰ΩÜËØ∑Á°ÆËÆ§Ôºö{Colors.ENDC}")
            print("    ‚Ä¢ Êù°‰ª∂Ê£ÄÊü•ÊòØÂê¶ÂÖÖÂàÜÔºà‰∏çÂ≠òÂú®ÁªïËøáÊñπÊ≥ïÔºâ")
            print("    ‚Ä¢ ÊòØÂê¶Ë¶ÜÁõñÊâÄÊúâÂèØËÉΩÁöÑÊîªÂáªË∑ØÂæÑ")
            print("    ‚Ä¢ ÊòØÂê¶Ê≠£Á°Æ‰ΩøÁî®‰∫Ü msg.sender ËÄå‰∏çÊòØ tx.origin")
    
    def _generate_html_report(self, report: Dict, output_path: str):
        """ÁîüÊàêHTMLÊä•Âëä"""
        html_content = f"""
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Êô∫ËÉΩÂêàÁ∫¶Ê±°ÁÇπÂàÜÊûêÊä•Âëä</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }}
        .container {{ max-width: 1200px; margin: 0 auto; background: white; padding: 30px; border-radius: 8px; }}
        h1 {{ color: #333; border-bottom: 3px solid #4CAF50; padding-bottom: 10px; }}
        h2 {{ color: #555; margin-top: 30px; }}
        .summary {{ background: #e8f5e9; padding: 20px; border-radius: 5px; margin: 20px 0; }}
        .vulnerable {{ color: #f44336; font-weight: bold; }}
        .safe {{ color: #4CAF50; font-weight: bold; }}
        .variable {{ border: 1px solid #ddd; margin: 20px 0; padding: 15px; border-radius: 5px; }}
        .risk {{ background: #ffebee; padding: 10px; margin: 10px 0; border-left: 4px solid #f44336; }}
        .code {{ background: #f5f5f5; padding: 10px; font-family: monospace; margin: 5px 0; border-radius: 3px; }}
        .timestamp {{ color: #999; font-size: 0.9em; }}
    </style>
</head>
<body>
    <div class="container">
        <h1>üîí Êô∫ËÉΩÂêàÁ∫¶Ê±°ÁÇπÂàÜÊûêÊä•Âëä</h1>
        <p class="timestamp">ÁîüÊàêÊó∂Èó¥: {report['analysis_time']}</p>
        <p>Ê∫êÊñá‰ª∂: <code>{report['source_file']}</code></p>
        
        <div class="summary">
            <h2>üìä ÂàÜÊûêÊ¶ÇË¶Å</h2>
            <p>ÊÄªÂèòÈáèÊï∞: {report['summary']['total_variables']}</p>
            <p class="vulnerable">ÂèóÊ±°ÁÇπÂΩ±Âìç: {report['summary']['vulnerable_variables']}</p>
            <p class="safe">ÂÆâÂÖ®ÂèòÈáè: {report['summary']['safe_variables']}</p>
        </div>
        
        <h2>üìù ËØ¶ÁªÜÁªìÊûú</h2>
"""
        
        for idx, result in enumerate(report['results'], 1):
            status_class = 'vulnerable' if result['has_taint'] else 'safe'
            status_text = '‚ö†Ô∏è Ê£ÄÊµãÂà∞Ê±°ÁÇπ' if result['has_taint'] else '‚úÖ ÂÆâÂÖ®'
            
            html_content += f"""
        <div class="variable">
            <h3>[{idx}] ÂèòÈáè: {result['variable']}</h3>
            <p class="{status_class}">Áä∂ÊÄÅ: {status_text}</p>
            <p>Â≠òÂÇ®ÊßΩ‰Ωç: {result['storage_slot']}</p>
"""
            
            if result['has_taint']:
                html_content += f"<p>Ê±°ÁÇπË∑ØÂæÑÊï∞: {result['taint_paths_count']}</p>"
            
            if result['risk_locations']:
                html_content += "<h4>‚ö†Ô∏è È£éÈô©‰ΩçÁΩÆ:</h4>"
                for risk in result['risk_locations']:
                    html_content += f"""
                <div class="risk">
                    <p>Ë°å {risk['line']} (ÂáΩÊï∞: {risk['function'] or 'Êú™Áü•'})</p>
                    <div class="code">{risk['code']}</div>
                </div>
"""
            
            html_content += "</div>"
        
        html_content += """
    </div>
</body>
</html>
"""
        
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(html_content)


# ============================================================================
# ‰∏ªÊµÅÁ®ã
# ============================================================================

class AllInOneAnalyzer:
    """‰∏Ä‰ΩìÂåñÂàÜÊûêÂô®"""
    
    def __init__(self, solc_version: str, key_variables: List[str], 
                 contract_path: str, output_dir: str = "analysis_output"):
        self.solc_version = solc_version
        self.key_variables = key_variables
        self.contract_path = contract_path
        self.output_dir = output_dir
        
        # ÂàõÂª∫ËæìÂá∫ÁõÆÂΩï
        os.makedirs(output_dir, exist_ok=True)
        os.makedirs(os.path.join(output_dir, "intermediate"), exist_ok=True)
    
    def run(self) -> Dict:
        """ËøêË°åÂÆåÊï¥ÂàÜÊûêÊµÅÁ®ã"""
        print(f"\n{Colors.BOLD}{Colors.HEADER}{'=' * 80}{Colors.ENDC}")
        print(f"{Colors.BOLD}{Colors.HEADER}Êô∫ËÉΩÂêàÁ∫¶‰∏Ä‰ΩìÂåñÊ±°ÁÇπÂàÜÊûêÂ∑•ÂÖ∑{Colors.ENDC}")
        print(f"{Colors.BOLD}{Colors.HEADER}{'=' * 80}{Colors.ENDC}")
        print(f"\nÈÖçÁΩÆ:")
        print(f"  SolcÁâàÊú¨: {self.solc_version}")
        print(f"  ÂêàÁ∫¶Ë∑ØÂæÑ: {self.contract_path}")
        print(f"  ÂÖ≥ÈîÆÂèòÈáè: {', '.join(self.key_variables)}")
        print(f"  ËæìÂá∫ÁõÆÂΩï: {self.output_dir}")
        
        try:
            # Ê≠•È™§1: Ê£ÄÊü•ÂíåÂàáÊç¢SolcÁâàÊú¨
            solc_manager = SolcManager(self.solc_version)
            if not solc_manager.check_and_switch_version():
                return None
            
            # Ê≠•È™§2: ÁºñËØëÂêàÁ∫¶
            compiler = ContractCompiler(solc_manager.solc_path, self.output_dir)
            if not compiler.compile(self.contract_path):
                return None
            
            # Ê≠•È™§3: Â≠óËäÇÁ†ÅÂàÜÊûê
            bytecode_analyzer = BytecodeAnalyzer(
                compiler.runtime_bytecode,
                self.key_variables,
                self.output_dir
            )
            if not bytecode_analyzer.analyze():
                return None
            
            # Ê≠•È™§4: Ê±°ÁÇπÂàÜÊûê
            taint_analyzer = TaintAnalyzer(bytecode_analyzer, self.output_dir)
            if not taint_analyzer.analyze():
                return None
            
            # Ê≠•È™§5: Ê∫êÁ†ÅÊò†Â∞Ñ
            source_mapper = SourceMapper(self.contract_path, self.output_dir)
            mapped_results = source_mapper.map_to_source(
                taint_analyzer.taint_results,
                bytecode_analyzer
            )
            
            # Ê≠•È™§6: ÁîüÊàêÊä•Âëä
            report_generator = ReportGenerator(self.output_dir, self.contract_path)
            final_report = report_generator.generate(mapped_results)
            
            # ÂÆåÊàê
            print(f"\n{Colors.BOLD}{Colors.GREEN}{'=' * 80}{Colors.ENDC}")
            print(f"{Colors.BOLD}{Colors.GREEN}‚úÖ ÂàÜÊûêÂÆåÊàêÔºÅ{Colors.ENDC}")
            print(f"{Colors.BOLD}{Colors.GREEN}{'=' * 80}{Colors.ENDC}")
            print(f"\nÊâÄÊúâÁªìÊûúÂ∑≤‰øùÂ≠òÂà∞: {Colors.CYAN}{self.output_dir}/{Colors.ENDC}")
            print(f"  - ÊúÄÁªàÊä•Âëä: final_report.json")
            print(f"  - HTMLÊä•Âëä: final_report.html")
            print(f"  - ‰∏≠Èó¥ÁªìÊûú: intermediate/")
            
            return final_report
            
        except Exception as e:
            print(f"\n{Colors.RED}‚ùå ÂàÜÊûêËøáÁ®ã‰∏≠ÂèëÁîüÈîôËØØ: {e}{Colors.ENDC}")
            import traceback
            traceback.print_exc()
            return None


# ============================================================================
# Á®ãÂ∫èÂÖ•Âè£
# ============================================================================

def main():
    """‰∏ªÂáΩÊï∞"""
    
    # ‰ΩøÁî®ÈÖçÁΩÆÂå∫ÂüüÁöÑÂèÇÊï∞ËøêË°åÂàÜÊûê
    analyzer = AllInOneAnalyzer(
        solc_version=SOLC_VERSION,
        key_variables=KEY_VARIABLES,
        contract_path=CONTRACT_PATH,
        output_dir=OUTPUT_DIR
    )
    
    result = analyzer.run()
    
    if result:
        sys.exit(0)
    else:
        sys.exit(1)


if __name__ == "__main__":
    main()

